{
  "channel": {
    "id": "UCbRP3c757lWg9M-U7TyEkXA",
    "name": "Theo Browne",
    "description": "Theo is a software dev, AI nerd, TypeScript sympathizer, creator of T3 Chat and the T3 Stack."
  },
  "videoId": "UiCEejcV5N4",
  "title": "React got hacked. It's really, really bad.",
  "url": "https://www.youtube.com/watch?v=UiCEejcV5N4",
  "publishedAt": "2025-12-08T21:25:48.367Z",
  "description": "Yes, React actually got hacked...\n\nThank you WorkOS for sponsoring! Check them out at: https://soydev.link/workos\n\nSOURCES\nhttps://x.com/rauchg/status/1997362942929440937\nhttps://x.com/duborges/sta...",
  "thumbnailUrl": "https://i.ytimg.com/vi/UiCEejcV5N4/hqdefault.jpg?sqp=-oaymwEcCNACELwBSFXyq4qpAw4IARUAAIhCGAFwAcABBg==&rs=AOn4CLCDnNlahlbyUEAv70SN2wGLmSW9sA",
  "transcript": [
    {
      "text": "Sadly, this one isn't clickbait. React got hacked, and it's pretty bad. On December 3rd, a CVE regarding React went",
      "duration": 6960,
      "offset": "80"
    },
    {
      "text": "public, showcasing an exploit that was possible in versions 19, 19.1, 1911, and",
      "duration": 5679,
      "offset": "7040"
    },
    {
      "text": "19.2 of React. This is an exploit that allows for the server component flight protocol, which is how data is passed",
      "duration": 6161,
      "offset": "12719"
    },
    {
      "text": "between the backend and the front end, to be hijacked to allow for remote code execution on the server. This is",
      "duration": 5600,
      "offset": "18880"
    },
    {
      "text": "basically as bad as it gets. Not even basically. It got a 10 for the severity score in the official ZVE. Like it's",
      "duration": 7840,
      "offset": "24480"
    },
    {
      "text": "this is as bad as it gets. It's one of the worst exploits that we've ever seen in the modern web. And the story of how",
      "duration": 6320,
      "offset": "32320"
    },
    {
      "text": "it was found, how it could be exploited, the people who have already been affected, and most importantly, the entire industry working together to try",
      "duration": 7599,
      "offset": "38640"
    },
    {
      "text": "and prevent this from affecting users is a really impressive story. I actually chose to delay my coverage a little bit",
      "duration": 6960,
      "offset": "46239"
    },
    {
      "text": "because raising awareness of the exploit itself could cause as much damage as it resolves because people knowing how to",
      "duration": 7040,
      "offset": "53199"
    },
    {
      "text": "do this exploit is scary. People like poor Eduardo have already been hacked as",
      "duration": 5041,
      "offset": "60239"
    },
    {
      "text": "a result of this which is terrifying. It is worth noting that if you're on a major web provider like Cloudflare,",
      "duration": 5199,
      "offset": "65280"
    },
    {
      "text": "Verscell or Netlefi that's more in the know for the React world, they have firewall mitigations that mitigate most",
      "duration": 6241,
      "offset": "70479"
    },
    {
      "text": "of the risk. There is still potential they can be worked around, which is why you really, really, really should update to the latest version of React for the",
      "duration": 6640,
      "offset": "76720"
    },
    {
      "text": "minor that you're on. But since Eduardo here wasn't on Verscell, he was on Hetner, he ended up getting hacked",
      "duration": 5920,
      "offset": "83360"
    },
    {
      "text": "pretty bad. There is so much to dive into here from how the exploit was found to how it affects people to what we can",
      "duration": 6159,
      "offset": "89280"
    },
    {
      "text": "do to prevent things like this going forward. I have no good transition for the ad spot here. Just roll it and we'll",
      "duration": 5040,
      "offset": "95439"
    },
    {
      "text": "cover the rest in a sec. I have two questions for you. First, does your app have any users? If the answer is no, you can skip this ad. But if it does,",
      "duration": 6401,
      "offset": "100479"
    },
    {
      "text": "question two is, are you ready to take on your first enterprise customers? If Salesforce hit you up today and said,",
      "duration": 5120,
      "offset": "106880"
    },
    {
      "text": "\"Hey, we love your app. We really want to use it at the company. Can you get us set up with Octa? Just put us in touch with your IT team. Do you even have an",
      "duration": 6159,
      "offset": "112000"
    },
    {
      "text": "IT team ready to go to do all of that setup?\" It's obnoxious. And that's why today's sponsor is so clutch. Work OS is",
      "duration": 6401,
      "offset": "118159"
    },
    {
      "text": "the place you should start if you want to have enterprise customers. Even if not yet, if it's a plan in the future,",
      "duration": 5039,
      "offset": "124560"
    },
    {
      "text": "you really should make the switch. I don't even want to think about how many potential enterprise deals we lost because we didn't have the ability to",
      "duration": 6161,
      "offset": "129599"
    },
    {
      "text": "onboard those customers because we didn't have this set up right. I rolled my own offer T3 chat and I've been regretting it for a year now, which is",
      "duration": 6720,
      "offset": "135760"
    },
    {
      "text": "why we just completed the move over to work OS. Yes, we actually made the move ourselves. There are so many reasons why",
      "duration": 5360,
      "offset": "142480"
    },
    {
      "text": "we did this move, but honestly, the admin portal is one of the best ones. It's so easy to set up real companies on",
      "duration": 5920,
      "offset": "147840"
    },
    {
      "text": "your platform. I don't know if you had to deal with this before, but the hell of trying to onboard another company onto your offplatform is miserable,",
      "duration": 6960,
      "offset": "153760"
    },
    {
      "text": "especially if you don't have it set up just right. With admin portal, you literally send them a link, they click the configure single sign on button,",
      "duration": 5840,
      "offset": "160720"
    },
    {
      "text": "pick whichever identity provider they're using at their company, and you're good to go. The alternative to work OS isn't",
      "duration": 5440,
      "offset": "166560"
    },
    {
      "text": "rolling your own off. The alternative to work OS is hiring a whole team of people to deal with all this crap. So, it's got to be super expensive, right? Not only",
      "duration": 6640,
      "offset": "172000"
    },
    {
      "text": "is it surprisingly cheap, your first million users are free. I've been super impressed since we moved over and I bet",
      "duration": 6160,
      "offset": "178640"
    },
    {
      "text": "you will be too at swive.linkworks. There's a couple key questions I want to make sure we answer through this. How",
      "duration": 5439,
      "offset": "184800"
    },
    {
      "text": "does it work? How is it found? What is affected? And how do I fix it? Excited to dive into all of these with you guys.",
      "duration": 6720,
      "offset": "190239"
    },
    {
      "text": "But first, of course, we need to talk about how it works. GMA did a pretty good write up on this. The current code",
      "duration": 5681,
      "offset": "196959"
    },
    {
      "text": "name for the exploit is React to shell because it lets you abuse the React protocol to get shell level execution,",
      "duration": 6239,
      "offset": "202640"
    },
    {
      "text": "which is terrifying. This strange data structure is responsible for many sleepless nights this week across the",
      "duration": 5041,
      "offset": "208879"
    },
    {
      "text": "industry. This is the now infamous react to shell payload as discovered by Lachlan Davidson now widely circulating.",
      "duration": 6160,
      "offset": "213920"
    },
    {
      "text": "It's a small thing, but I do love how much they are trying to get positive like credit to the person who found",
      "duration": 7519,
      "offset": "220080"
    },
    {
      "text": "this. That dev could have went and abused the hell out of this and done terrible things without disclosing it.",
      "duration": 5920,
      "offset": "227599"
    },
    {
      "text": "And it would have taken forever for people to even notice. I wanted to provide my point of view on the attack, how it came about, and what we're doing,",
      "duration": 6401,
      "offset": "233519"
    },
    {
      "text": "as well as the lessons learned. So, that payload that he linked is this, which doesn't look too weird if you've seen",
      "duration": 7039,
      "offset": "239920"
    },
    {
      "text": "the payloads inside of like server components when things are being passed to and from the server in a modern",
      "duration": 5441,
      "offset": "246959"
    },
    {
      "text": "server component react app. You might hear me saying server component in server a lot. And there's a reason for that. And no, the reason isn't because",
      "duration": 6239,
      "offset": "252400"
    },
    {
      "text": "this is Nex.js specific. You'll understand the reasons very soon. But here we see the resolved model payload.",
      "duration": 6881,
      "offset": "258639"
    },
    {
      "text": "It just has a then on it which is how it serializes promises. And then in here this fourth section has a console log in",
      "duration": 7440,
      "offset": "265520"
    },
    {
      "text": "it which is very very specific. I think we need to do a tiny overview of React",
      "duration": 5440,
      "offset": "272960"
    },
    {
      "text": "server component stuff so you can better understand how an exploit like this can happen. I just set up a really complex",
      "duration": 5840,
      "offset": "278400"
    },
    {
      "text": "Nex.js app. As you can see this is so complicated. I want to just demo some of the cool things in server components",
      "duration": 6320,
      "offset": "284240"
    },
    {
      "text": "that make this all matter. Let's say we have some data in here that we want to",
      "duration": 5359,
      "offset": "290560"
    },
    {
      "text": "have come in later because it takes some time. I'll make a function slow",
      "duration": 5201,
      "offset": "295919"
    },
    {
      "text": "component and it's going to be async because it's a slow component because to do things. So in the slow component,",
      "duration": 5600,
      "offset": "301120"
    },
    {
      "text": "we'll wait that second and then render slow component. Cool. I'll make this like 3 seconds instead for a better",
      "duration": 6400,
      "offset": "306720"
    },
    {
      "text": "demo. I'll put that in the page. And now when I refresh error in input stream.",
      "duration": 5040,
      "offset": "313120"
    },
    {
      "text": "Interesting. What's it mad about? Oh, it just took a sec to like reblog itself. So, watch what happens. I just opened",
      "duration": 6319,
      "offset": "318160"
    },
    {
      "text": "it. One, two, three, then it works. We have to wait for all of the async things",
      "duration": 5521,
      "offset": "324479"
    },
    {
      "text": "to be completed before it can generate the HTML that it sends down to the user. But this is where server components have",
      "duration": 5440,
      "offset": "330000"
    },
    {
      "text": "some really cool superpowers. If we put a suspense boundary around the slow component, a lot of times when I load",
      "duration": 5920,
      "offset": "335440"
    },
    {
      "text": "the page now, it says loading there and then the rest comes in. And whenever I refresh, sometimes it gets a weird dev",
      "duration": 7520,
      "offset": "341360"
    },
    {
      "text": "debug error because I'm in Firefox. But here it's loading. We wait and then the content comes in. It lets you have some",
      "duration": 7120,
      "offset": "348880"
    },
    {
      "text": "things that get responded with immediately and other things that take time. And part of how it does this is",
      "duration": 6080,
      "offset": "356000"
    },
    {
      "text": "effectively serializing the data that needs to come in later. Here it's much",
      "duration": 5040,
      "offset": "362080"
    },
    {
      "text": "more focused on like the React like component protocol and the actual elements being snuck into the page. you",
      "duration": 5919,
      "offset": "367120"
    },
    {
      "text": "can look at the JS and it effectively is loading another element in invisibly and then using a tiny JS payload to swap it",
      "duration": 6961,
      "offset": "373039"
    },
    {
      "text": "in to the right place in the DOM which is really cool and interesting but that's not the part that this exploit",
      "duration": 6160,
      "offset": "380000"
    },
    {
      "text": "touches on. Let's say we have a button component that needs some data before it",
      "duration": 5599,
      "offset": "386160"
    },
    {
      "text": "can render. export function some button and this button needs a value that is a",
      "duration": 7601,
      "offset": "391759"
    },
    {
      "text": "string and it will show that value when we render it. This value we'll say has",
      "duration": 5360,
      "offset": "399360"
    },
    {
      "text": "to be fetched somewhere and take some time. So I'll make a fake server function that's like function async",
      "duration": 5039,
      "offset": "404720"
    },
    {
      "text": "function get slow data here we'll await and then return slow data just kill this",
      "duration": 6641,
      "offset": "409759"
    },
    {
      "text": "component and then use client. So the easy thing I could do here is in here",
      "duration": 7519,
      "offset": "416400"
    },
    {
      "text": "await get slow data. So like con data equals await get slow data and then pass",
      "duration": 5280,
      "offset": "423919"
    },
    {
      "text": "it to the button component. But then this has to be async. I can't really determine anything there. What's really",
      "duration": 6241,
      "offset": "429199"
    },
    {
      "text": "cool with server components is you can pass down a promise. So if I pass this down instead of value string, it's value",
      "duration": 7360,
      "offset": "435440"
    },
    {
      "text": "but it's a promise or a string instead. What I can do differently is pass that",
      "duration": 5519,
      "offset": "442800"
    },
    {
      "text": "directly. I grab some button",
      "duration": 4841,
      "offset": "448319"
    },
    {
      "text": "and now I'm passing this promise. But I can't do anything just with the promise. I try to render that, it's not going to",
      "duration": 5119,
      "offset": "453360"
    },
    {
      "text": "work. So I can do a couple different things. I could do the fancy like use effect use state to get it. But there's",
      "duration": 5280,
      "offset": "458479"
    },
    {
      "text": "also just use. Look at that. It all figured itself out. So now I have the data from using this promise. You get",
      "duration": 7681,
      "offset": "463759"
    },
    {
      "text": "the idea. But since it's literally just a promise, I can go a little further like use effect",
      "duration": 7319,
      "offset": "471440"
    },
    {
      "text": "and now I have this use effect that will only run when value changes which it won't cuz it's a promise. This promise gets passed down to the client component",
      "duration": 6560,
      "offset": "489919"
    },
    {
      "text": "and then you can do things with it. So if we look at the terminal here, you will see after the promise loads, which",
      "duration": 5681,
      "offset": "496479"
    },
    {
      "text": "takes a few seconds, you get the promise results slow data because I just passed a promise from the server to the client.",
      "duration": 6640,
      "offset": "502160"
    },
    {
      "text": "You cannot convince me this isn't cool as The fact that you can take a promise or data or work being done on",
      "duration": 6320,
      "offset": "508800"
    },
    {
      "text": "the server, pass it to a client component and then await it on client. What use does here is it is suspending",
      "duration": 6398,
      "offset": "515120"
    },
    {
      "text": "until this promise is resolved. So if I comment this out and instead have data set datas use state and then I set the",
      "duration": 7681,
      "offset": "521519"
    },
    {
      "text": "data when we get it. I could have a different case here where it's on client. If no data return loading, I can",
      "duration": 5920,
      "offset": "529200"
    },
    {
      "text": "now kill the suspense boundaries here. And something broke in the DOM.",
      "duration": 6480,
      "offset": "535120"
    },
    {
      "text": "There we go. I think that's cool as The fact that you can take a promise and pass it",
      "duration": 6480,
      "offset": "541600"
    },
    {
      "text": "to a client component and use it how you would want to is incredible. Obviously, you shouldn't do it this way. Like, we",
      "duration": 6240,
      "offset": "548080"
    },
    {
      "text": "have the primitives built in to do it better. Like, const data is use. And now we can just kill this state. So, it will",
      "duration": 5840,
      "offset": "554320"
    },
    {
      "text": "always exist now, which is another one of those cool differences cuz instead of having the different states in this component, what this does is it prevents",
      "duration": 6640,
      "offset": "560160"
    },
    {
      "text": "this component from rendering until the data has been resolved. It's it's so cool. These patterns are great. There's a reason that the React team has put so",
      "duration": 6080,
      "offset": "566800"
    },
    {
      "text": "much time into this. But in order for all of this to work, in order to have the concept of like serializing a promise from server to client, you have",
      "duration": 7280,
      "offset": "572880"
    },
    {
      "text": "to make a protocol for it. Because web standards don't have a concept of serializing a promise. If you want to do",
      "duration": 6640,
      "offset": "580160"
    },
    {
      "text": "things like this, you can't just rely on JSON. It's not that simple. You need to do more. You need to make your own protocol, which is what React did with",
      "duration": 6960,
      "offset": "586800"
    },
    {
      "text": "the flight protocol. It's a big part of how these things being passed from server to client and also client to",
      "duration": 5040,
      "offset": "593760"
    },
    {
      "text": "server were able to work. There is one last important piece which is how the",
      "duration": 5360,
      "offset": "598800"
    },
    {
      "text": "form data and actions behave. So I'll make another component in here function",
      "duration": 5600,
      "offset": "604160"
    },
    {
      "text": "form example. So we have our form, we have this input and then submit. And if I type something here like something and",
      "duration": 7840,
      "offset": "609760"
    },
    {
      "text": "hit submit work is happening. But if I go over here, you'll see form data. Form data",
      "duration": 6080,
      "offset": "617600"
    },
    {
      "text": "has this action identifier and name colon something. Obviously this comes through with the form data because this",
      "duration": 6320,
      "offset": "623680"
    },
    {
      "text": "is the form and when you submit it, it goes to the server with the contents of the form. But what the is this",
      "duration": 5519,
      "offset": "630000"
    },
    {
      "text": "thing? What's this action ID empty string value? This is how React allows",
      "duration": 6081,
      "offset": "635519"
    },
    {
      "text": "you to do cool things like write an action in line in this form. So the server code that gets executed when you",
      "duration": 6400,
      "offset": "641600"
    },
    {
      "text": "submit this form is identified by the server by putting a hidden field in this",
      "duration": 5200,
      "offset": "648000"
    },
    {
      "text": "form that is passed by the client to the server when you fire it. Because if you had three different forms and all of",
      "duration": 5840,
      "offset": "653200"
    },
    {
      "text": "them are posed to the same URL, how is React and in this case Nex going to identify which is which? The actions",
      "duration": 6000,
      "offset": "659040"
    },
    {
      "text": "protocol is a big part of how it does it. So if we actually look at the DOM here, you will see in this form, there's",
      "duration": 6960,
      "offset": "665040"
    },
    {
      "text": "more going on than just the things we wrote. We have this hidden input type is hidden name, action ID, all of that.",
      "duration": 7120,
      "offset": "672000"
    },
    {
      "text": "This is how the right function on the server is identified from what's submitted on the client. Otherwise,",
      "duration": 5360,
      "offset": "679120"
    },
    {
      "text": "there'd be no way to link these things together. These are the complex layers that have enabled a CVE like this to",
      "duration": 6240,
      "offset": "684480"
    },
    {
      "text": "happen. Not that like these things are inherently bad and insecure, more that new things had to be invented to allow",
      "duration": 6480,
      "offset": "690720"
    },
    {
      "text": "for these patterns to exist. One more quick example of how this can get messy. If you have some value in the body of",
      "duration": 6879,
      "offset": "697200"
    },
    {
      "text": "this component and you want to use that down here, how does it know what that value was? Because it's not in the form",
      "duration": 7121,
      "offset": "704079"
    },
    {
      "text": "and the form is submitting. So, we want to have the right random value for when this ran. So what React will do is it",
      "duration": 7199,
      "offset": "711200"
    },
    {
      "text": "will quietly embed a hashed version of this inside of the component. Let me",
      "duration": 6961,
      "offset": "718399"
    },
    {
      "text": "save. And that see all of these new fields that appeared. What's happening here is it's serializing an encrypted",
      "duration": 6000,
      "offset": "725360"
    },
    {
      "text": "version of the data that exists in this closure, embedding it in the form, and",
      "duration": 5200,
      "offset": "731360"
    },
    {
      "text": "then that gets submitted up when you hit submit like any data in a form does where the server can decrypt it and",
      "duration": 5760,
      "offset": "736560"
    },
    {
      "text": "effectively recreate the state it was in when you defined this function. It allows for the intuitive behavior to",
      "duration": 5280,
      "offset": "742320"
    },
    {
      "text": "work which is I have some value here. I define an action. I call this value in",
      "duration": 5359,
      "offset": "747600"
    },
    {
      "text": "this subclosure and it works. But you need to have that data there in order to",
      "duration": 5680,
      "offset": "752959"
    },
    {
      "text": "recreate the state because this component run for this specific instance that you're seeing doesn't exist on the",
      "duration": 7041,
      "offset": "758639"
    },
    {
      "text": "server after it sent the response. So it has to be recreated when you run your action. And this is super super cool for",
      "duration": 5839,
      "offset": "765680"
    },
    {
      "text": "a bunch of reasons. One of the biggest is you don't need JavaScript on for it to work. because we're just using traditional form data and if your server",
      "duration": 6801,
      "offset": "771519"
    },
    {
      "text": "turns off and back on or you're using serverless or anything like that, it just works as expected. It is incredibly",
      "duration": 6639,
      "offset": "778320"
    },
    {
      "text": "impressive that this chaotic looking solution when you look at the DOM here gives such a simple and intuitive",
      "duration": 6801,
      "offset": "784959"
    },
    {
      "text": "developer experience that also composes really well too. I'm very impressed with",
      "duration": 5360,
      "offset": "791760"
    },
    {
      "text": "this stuff. I was skeptical at first, but there was a lot of use cases like let's say that instead of this being a form, this is a row in a table and you",
      "duration": 6719,
      "offset": "797120"
    },
    {
      "text": "want to have a delete button. Instead of having to pass the ID of the deletion every single time and having to either",
      "duration": 6161,
      "offset": "803839"
    },
    {
      "text": "put that in the form and it doesn't work with Noode.js or having to call a specific function with the right ID at the right time, it just exists as part",
      "duration": 6480,
      "offset": "810000"
    },
    {
      "text": "of the component render and the action can just be a delete click. It makes a lot of things like that way simpler and",
      "duration": 6400,
      "offset": "816480"
    },
    {
      "text": "simple makes maintaining your codebase and scaling your codebase way easier. It's a good thing. These are hard things",
      "duration": 5680,
      "offset": "822880"
    },
    {
      "text": "that were invented by the React team in order to enable better developer experience. But at the core of all of",
      "duration": 5120,
      "offset": "828560"
    },
    {
      "text": "this is that flight protocol which allows for things other than just form data in JSON to be sent up and down and",
      "duration": 7920,
      "offset": "833680"
    },
    {
      "text": "to encode other things in those payloads. So if we go back to this payload that Garmmo had posted from",
      "duration": 6720,
      "offset": "841600"
    },
    {
      "text": "Lachlan the dev who figured this all out you'll see here we have our initial payload and then we have this key one",
      "duration": 8079,
      "offset": "848320"
    },
    {
      "text": "that has a value of then map then length yada yada thes are here because this is",
      "duration": 7521,
      "offset": "856399"
    },
    {
      "text": "a promise being serialized over the wire which allows you to know on the client side okay there is more data coming it",
      "duration": 6560,
      "offset": "863920"
    },
    {
      "text": "will be in this rough shape I can wait until that data comes here and also the same roughly on the server. So what",
      "duration": 6640,
      "offset": "870480"
    },
    {
      "text": "makes this payload so special? Here is the most minimal possible working exploit to take advantage of this status",
      "duration": 7360,
      "offset": "877120"
    },
    {
      "text": "resolve model reason zero. We have the response prefix of console log and then a constructor in the form data getter.",
      "duration": 8400,
      "offset": "884480"
    },
    {
      "text": "So how does this work? If this body sent to any server running the vulnerable flight code like a modern next app, the",
      "duration": 5040,
      "offset": "892880"
    },
    {
      "text": "console log string will be evaluated server side. That string can do virtually anything. run programs, extract secrets, make network calls. In",
      "duration": 7039,
      "offset": "897920"
    },
    {
      "text": "the case of poor Eduardo here, get rude on his machine and start Bitcoin mining on it. The two key ingredients of the",
      "duration": 5921,
      "offset": "904959"
    },
    {
      "text": "exploits zero and one are called chunks in flight lingo. The entry point of the exploit is, as I foreshadowed earlier,",
      "duration": 6240,
      "offset": "910880"
    },
    {
      "text": "flight's key and awesome capability to stream promised data. The syntax for that is the at in the one the dollar",
      "duration": 7279,
      "offset": "917120"
    },
    {
      "text": "sign at zero chunk. It's saying that zero is a promise. So, what is the resolve model thing? It's a genius piece",
      "duration": 5680,
      "offset": "924399"
    },
    {
      "text": "of the exploit. While flight is intended to transport user objects, Lachlan found a way to confuse React. He's essentially",
      "duration": 6241,
      "offset": "930079"
    },
    {
      "text": "expressing internal state, which is an object that's supposed to be private and contains React's internal bookkeeping.",
      "duration": 5840,
      "offset": "936320"
    },
    {
      "text": "This is similar to the stuff I was showing where it's doing the form identification and passing this data in",
      "duration": 6239,
      "offset": "942160"
    },
    {
      "text": "for you. It's how React keeps track of the state on client so that it could recreate it properly on server. Anytime",
      "duration": 6161,
      "offset": "948399"
    },
    {
      "text": "React has to represent an in-flight object, it uses an internal data structure to keep track of the status. in resolve model means that a value is",
      "duration": 6079,
      "offset": "954560"
    },
    {
      "text": "ready to be used. The key to the hack is the then piece. In JavaScript, if an object quacks like a promise, which",
      "duration": 6161,
      "offset": "960639"
    },
    {
      "text": "means it has a then, then it's treated as a promise. Since we used this syntax, React will eventually await the data. To",
      "duration": 6719,
      "offset": "966800"
    },
    {
      "text": "abuse this machinery, we set then the dollar one col then, which will then be called recursively. This is where",
      "duration": 6240,
      "offset": "973519"
    },
    {
      "text": "flight's glaring emission happens. The colon syntax is designed to introduce references between userdefined objects,",
      "duration": 6801,
      "offset": "979759"
    },
    {
      "text": "not to access the internal machinery of the JS runtime itself. A lot of exploits like this in JavaScript land are people",
      "duration": 6719,
      "offset": "986560"
    },
    {
      "text": "accessing proto or the prototype objects similar ways. But if you're freely able to access those, that's a smoking gun",
      "duration": 7201,
      "offset": "993279"
    },
    {
      "text": "for this type of vulnerability. The patch was to introduce a has own property call here to make sure that the",
      "duration": 6799,
      "offset": "1000480"
    },
    {
      "text": "value that we are decoding hasn't been modified or had these things overridden in any meaningful way. This is the",
      "duration": 5761,
      "offset": "1007279"
    },
    {
      "text": "primary safety emission in React and it's a fundamental one is comparable to an out-of-bounds memory access and C or",
      "duration": 5440,
      "offset": "1013040"
    },
    {
      "text": "use after free. Once we flow React into resolving the chunk, it's initialized with a hijacked fake underscore",
      "duration": 5760,
      "offset": "1018480"
    },
    {
      "text": "response. The next key the attack is to access a code evaluation mechanism. You'll notice the attack use a value",
      "duration": 5520,
      "offset": "1024240"
    },
    {
      "text": "that references a dollar sign B which stands for blob. Well, in this case, blob value then. Why did the attacker",
      "duration": 6158,
      "offset": "1029760"
    },
    {
      "text": "choose to represent a blob? In the React codebase, there's a couple lines that look like this. Where we have a blob and",
      "duration": 5361,
      "offset": "1035919"
    },
    {
      "text": "we take from the form data, we get on it with the blob key. Now that the attacker is controlling the form data as well as",
      "duration": 6320,
      "offset": "1041280"
    },
    {
      "text": "prefix, all that's left is to get the get to evaluate arbitrary code and then",
      "duration": 5280,
      "offset": "1047600"
    },
    {
      "text": "blob key to support it. And this is the last key to this puzzle. In JavaScript, there are two basic mechanisms to",
      "duration": 5520,
      "offset": "1052880"
    },
    {
      "text": "evaluate arbitrary code. Eval and new function, but neither are present here, right? Except for this mysterious get",
      "duration": 6560,
      "offset": "1058400"
    },
    {
      "text": "colon dollar sign 1 col then constructor piece. By accessing the then property, we're getting access to an instance of a",
      "duration": 6480,
      "offset": "1064960"
    },
    {
      "text": "function. And the JavaScript happily lets us access its constructor. Once again, something that could be prevented",
      "duration": 6000,
      "offset": "1071440"
    },
    {
      "text": "by a has own property check. Final exploit ends up semantically looking like this. Function console.log. Since",
      "duration": 7200,
      "offset": "1077440"
    },
    {
      "text": "they're passing this in through the prefix and the way that this is executed on the server side is prefix plus ID,",
      "duration": 6560,
      "offset": "1084640"
    },
    {
      "text": "adding the random content to the end of your exploit would cause the syntax to break. So they always put the comment",
      "duration": 6800,
      "offset": "1091200"
    },
    {
      "text": "syntax here because then when the ID gets added after it's resolved as a comment and gets ignored. One of the",
      "duration": 5120,
      "offset": "1098000"
    },
    {
      "text": "many clever layers here. As GMO said at the top, just position of a glaring emission of a safety check combined with",
      "duration": 5520,
      "offset": "1103120"
    },
    {
      "text": "a stunningly brilliant mechanism to exploit it. The solution is like a brain teaser, a riddle to test your hacking",
      "duration": 5120,
      "offset": "1108640"
    },
    {
      "text": "skills, or a capture the flag type of exercise. This is another instance of not trusting user input. It's so",
      "duration": 6000,
      "offset": "1113760"
    },
    {
      "text": "important to have every single layer you possibly can when a user is submitting data to your server and you are doing",
      "duration": 6400,
      "offset": "1119760"
    },
    {
      "text": "things based on it. This one was sly and subtle. It would have been very hard for anyone to see this. It's pretty",
      "duration": 5680,
      "offset": "1126160"
    },
    {
      "text": "impressive when you think about it how long React 19's been out for, how many people are building on it, that no one",
      "duration": 5040,
      "offset": "1131840"
    },
    {
      "text": "has noticed this yet. It's a very complex exploit to figure out the",
      "duration": 5840,
      "offset": "1136880"
    },
    {
      "text": "execution pipeline within the ReactFlight protocol deeply enough to find this one edge and sneak things",
      "duration": 7120,
      "offset": "1142720"
    },
    {
      "text": "through. It really is a genius exploit. So, we've now covered how does it work. We've roughly covered how was it found.",
      "duration": 6160,
      "offset": "1149840"
    },
    {
      "text": "Lachlan was a god digging deep in it and thankfully went through all of the correct reporting chains to get this",
      "duration": 6160,
      "offset": "1156000"
    },
    {
      "text": "identified and fixed. The report was privately disclosed way before the public one. The React team worked really",
      "duration": 5920,
      "offset": "1162160"
    },
    {
      "text": "hard to collaborate with various vendors that do a lot of hosting for modern React applications in order to get this",
      "duration": 5920,
      "offset": "1168080"
    },
    {
      "text": "stuff handled as much as possible on the server side. Since this problem lives so deeply in React itself, the best you can",
      "duration": 6720,
      "offset": "1174000"
    },
    {
      "text": "do outside of it on like the firewall level is try your best to identify payloads that match this shape and",
      "duration": 6880,
      "offset": "1180720"
    },
    {
      "text": "prevent them. But if another shape is discovered by someone exploiting this, the firewall checks cannot really",
      "duration": 6640,
      "offset": "1187600"
    },
    {
      "text": "protect you from it. So they did their best and took the existing shapes and",
      "duration": 5280,
      "offset": "1194240"
    },
    {
      "text": "things we know about the exploit and all of the major web providers that have Nex as a first class citizen have done their",
      "duration": 7279,
      "offset": "1199520"
    },
    {
      "text": "best to block this all on a firewall level. So there's a good chance you're safe even if you haven't updated. That said, make sure you're on the latest",
      "duration": 6000,
      "offset": "1206799"
    },
    {
      "text": "patch version like 1912 or 1921 because this has been fixed in all of the latest",
      "duration": 6401,
      "offset": "1212799"
    },
    {
      "text": "updates for React that were just pushed. And for the sake of poor Ricky who hasn't slept in a week, please please",
      "duration": 6400,
      "offset": "1219200"
    },
    {
      "text": "make sure you update. So we covered these. Now we should talk about what is affected. Obviously all of the demos",
      "duration": 6800,
      "offset": "1225600"
    },
    {
      "text": "I've been doing here have been next.js. That does not mean this only affects next. This exploit affects anything",
      "duration": 6720,
      "offset": "1232400"
    },
    {
      "text": "using React server components as recommended by meta because the exploit exists within the way that data is",
      "duration": 6160,
      "offset": "1239120"
    },
    {
      "text": "encoded and decoded for server components. The vulnerabilities present in 1909 1919 1911 192 for React server",
      "duration": 6720,
      "offset": "1245280"
    },
    {
      "text": "DOM Webpack, React server DOM parcel and React server DOM turbo pack and these are used in everything from React Router",
      "duration": 5919,
      "offset": "1252000"
    },
    {
      "text": "to Waku. They are not using Tanstack start because Tanstack starter components yet. But if they had",
      "duration": 5441,
      "offset": "1257919"
    },
    {
      "text": "introduced server components, it would likely also be affected. 1901, 1912, and 1921 have all remediated this. So if",
      "duration": 7280,
      "offset": "1263360"
    },
    {
      "text": "you're on any of these versions of React, you're good. And if you're on 18, you're fine. You should be able to",
      "duration": 5919,
      "offset": "1270640"
    },
    {
      "text": "update your app trivially if you're on any of the affected versions. You just change the latest patch and you're fine. It's very easy to mitigate if you can",
      "duration": 6401,
      "offset": "1276559"
    },
    {
      "text": "actually change the code that is deployed thankfully. Next, React Router, Wacu, Parcel/RSC, VJS Plugin RSC, and",
      "duration": 6719,
      "offset": "1282960"
    },
    {
      "text": "RWSDK are all affected. And as they say on the React blog, they've worked with a",
      "duration": 5201,
      "offset": "1289679"
    },
    {
      "text": "number of hosting providers to apply temporary mitigations. You should not depend on these to secure your app, and you should still update immediately. I",
      "duration": 6880,
      "offset": "1294880"
    },
    {
      "text": "know what your next question is going to be. I don't use server components so I am good. Right? Depends on the tools",
      "duration": 5279,
      "offset": "1301760"
    },
    {
      "text": "you're using and if server components are enabled at all because you can take an app that's all client components and",
      "duration": 5281,
      "offset": "1307039"
    },
    {
      "text": "if it has a server renderer at all running on a server that's yours or Verscell's, Cloudflares, Nellifis,",
      "duration": 6239,
      "offset": "1312320"
    },
    {
      "text": "whoevers, you can still hit this flight endpoint and trigger things. So, if you're not using server components, but",
      "duration": 5921,
      "offset": "1318559"
    },
    {
      "text": "you are using one of these late versions that includes any of the packages that were listed here, any of these that are",
      "duration": 6079,
      "offset": "1324480"
    },
    {
      "text": "able to do server components, you are potentially vulnerable and you really, really should update. Seriously, if",
      "duration": 5281,
      "offset": "1330559"
    },
    {
      "text": "you're on any of these versions or know anybody on any of these versions, be annoying until they update. This is one",
      "duration": 5839,
      "offset": "1335840"
    },
    {
      "text": "of the few times that you can be a righteous reply guy obnoxious If you're on one of these and have not",
      "duration": 5521,
      "offset": "1341679"
    },
    {
      "text": "updated, you need to now. I can't emphasize this enough. It is very very",
      "duration": 5440,
      "offset": "1347200"
    },
    {
      "text": "important that you update to the latest version as aggressively and soon as possible. They also posted a timeline",
      "duration": 6080,
      "offset": "1352640"
    },
    {
      "text": "which is really cool. Lachland originally reported this vulnerability via the metabug bounty on November 29th",
      "duration": 5600,
      "offset": "1358720"
    },
    {
      "text": "and by the 30th the researchers at Meta had confirmed and began working with the React team to fix. Literally 5 days",
      "duration": 6400,
      "offset": "1364320"
    },
    {
      "text": "later not even this went public. That is a crazy turnaround time to go from",
      "duration": 5520,
      "offset": "1370720"
    },
    {
      "text": "initial reporting to fixed worked with all the providers and publicly disclosed",
      "duration": 5360,
      "offset": "1376240"
    },
    {
      "text": "is insane. I have a lot of respect to them for going public with the disclosure as early as they did too",
      "duration": 5040,
      "offset": "1381600"
    },
    {
      "text": "because it's all in open- source stuff and they wanted to make sure people take the need to upgrade seriously. But it's",
      "duration": 6720,
      "offset": "1386640"
    },
    {
      "text": "also a tough balancing act because if you share enough detail of the exploit, you're giving misaligned people a nice",
      "duration": 6960,
      "offset": "1393360"
    },
    {
      "text": "edge where they can learn how to do the exploit from the resources that you provide. And if those people are faster",
      "duration": 5359,
      "offset": "1400320"
    },
    {
      "text": "than the people doing the patching, they're screwed. But finding the right balance of disclosing enough to make",
      "duration": 5120,
      "offset": "1405679"
    },
    {
      "text": "sure the severity is understood without giving usable reproductions that people can then go abuse, it's a tough balance.",
      "duration": 6961,
      "offset": "1410799"
    },
    {
      "text": "Even Aiden, who has been giving a lot of arguably deserved to the React Next teams historically, said that this was a",
      "duration": 5600,
      "offset": "1417760"
    },
    {
      "text": "world-class demo in how to handle critical vulnerabilities in large scale open source. They did really well. They did this all right. One more piece of",
      "duration": 5679,
      "offset": "1423360"
    },
    {
      "text": "Versel and Meta doing this responsibly. Malta, CTO of Verscell, just announced that they put out a new dedicated hacker",
      "duration": 6481,
      "offset": "1429039"
    },
    {
      "text": "one program for people who are finding ways to bypass the CVE protections they put on the firewall. Again, you're only",
      "duration": 7440,
      "offset": "1435520"
    },
    {
      "text": "safe if you update to the latest version of the package. But if you can't or haven't, the firewall is the only",
      "duration": 5120,
      "offset": "1442960"
    },
    {
      "text": "protection. They did their best to make it as safe as possible. But since it's a layer put around this really unsafe",
      "duration": 6160,
      "offset": "1448080"
    },
    {
      "text": "thing at the core, if you can find a way around it, the exploit is effectively still active. And that's why they put out this bounty. Because if you find one",
      "duration": 6240,
      "offset": "1454240"
    },
    {
      "text": "of those exploits, you can make 50k by telling them about it. Or you can go exploit it yourself, which was what",
      "duration": 6400,
      "offset": "1460480"
    },
    {
      "text": "happened to poor Eduardo here. Let's break down how he got hacked. Poor guy. I woke up to a terrifying email from",
      "duration": 5600,
      "offset": "1466880"
    },
    {
      "text": "Hzner. Net scan detected. My server was blocked and a botnet was using my IP to attack others. I dug into the logs and I",
      "duration": 5920,
      "offset": "1472480"
    },
    {
      "text": "found the anatomy of the attack. He looked at htop and saw his CPU usage was crazy. This random process running wild",
      "duration": 5519,
      "offset": "1478400"
    },
    {
      "text": "and connections to an IP address in the Netherlands. My server wasn't serving my app anymore. It was mining crypto for someone else. The culprit wasn't some",
      "duration": 6721,
      "offset": "1483919"
    },
    {
      "text": "SSH brute force. It was in his Nex.js container. The malware was sophisticated. It renamed itself to",
      "duration": 5519,
      "offset": "1490640"
    },
    {
      "text": "engine XS and Apache so it would look like a web server. It even had a killer script that would hunt other hacker miners and kill them so that his would",
      "duration": 6481,
      "offset": "1496159"
    },
    {
      "text": "get priority. The root cause is that the Nex.js CVE exploit almost certainly was",
      "duration": 5440,
      "offset": "1502640"
    },
    {
      "text": "what was used here. He's running on Nex 1554 behind Cloudflare DNS, but the recent fix on Cloudflare DNS didn't",
      "duration": 6640,
      "offset": "1508080"
    },
    {
      "text": "work. No, the Cloudflare DNS isn't going to put up a firewall in your next app on Hetner for you. No, not reasonable to",
      "duration": 6720,
      "offset": "1514720"
    },
    {
      "text": "expect that. Regardless, you should have updated. This is again you really need to update. The Docker container was running as root. Coolify deploys like",
      "duration": 7200,
      "offset": "1521440"
    },
    {
      "text": "this when using next packs and I never changed it. That is just how Nyx packs work by default from my understanding.",
      "duration": 5840,
      "offset": "1528640"
    },
    {
      "text": "But that is bad. His next app was deployed as root which means if you exploit the next app, you now have root.",
      "duration": 6079,
      "offset": "1534480"
    },
    {
      "text": "So because of the user root, the malware could install cron systemd and persistent scripts to survive reboots. So it's able to infect the whole server",
      "duration": 5761,
      "offset": "1540559"
    },
    {
      "text": "from a sing.js docker. The hacker installed a whole tool set in the instance. this Apache installer that's",
      "duration": 6479,
      "offset": "1546320"
    },
    {
      "text": "fake of course the cron route which would set up a cron to persist the exploit and the c.json JSON which was",
      "duration": 6000,
      "offset": "1552799"
    },
    {
      "text": "the wallet config which is where the money should be dumped when it mines fix kill the container scrub the host extract the malware for analysis real is",
      "duration": 6401,
      "offset": "1558799"
    },
    {
      "text": "in the docker file if you're deploying node next do not use the default route you must create a custom user and use",
      "duration": 5040,
      "offset": "1565200"
    },
    {
      "text": "that user instead your containers now it's important if you're running nextjs in a container in a server somewhere",
      "duration": 5919,
      "offset": "1570240"
    },
    {
      "text": "please go check this even if you're not on an exploitable version it's very useful to go check but the reason I was bringing this up now is how much money",
      "duration": 6561,
      "offset": "1576159"
    },
    {
      "text": "was made by the hacker this is somebody who chose to hack instead of disclose to be fair they are using a hack that",
      "duration": 5199,
      "offset": "1582720"
    },
    {
      "text": "already exists and is public. They're not sending any novel information, but they are exploiting it. And through all",
      "duration": 5521,
      "offset": "1587919"
    },
    {
      "text": "of their use with this, there's a wallet that the money gets dumped to. Since it's on blockchain, you can look at how",
      "duration": 5920,
      "offset": "1593440"
    },
    {
      "text": "much money they've made. $4.26 a day. So once again, if you do manage to find a",
      "duration": 5760,
      "offset": "1599360"
    },
    {
      "text": "novel exploit here, your options are maybe make $4 a day by using it and",
      "duration": 5280,
      "offset": "1605120"
    },
    {
      "text": "breaking the law or crazy report it to Hacker 1 to Verscell and potentially get",
      "duration": 6159,
      "offset": "1610400"
    },
    {
      "text": "paid $50,000. That's in my opinion a much better deal and that's why they put",
      "duration": 5041,
      "offset": "1616559"
    },
    {
      "text": "this up because it's important that they make the reward for reporting meaningfully better and more noble than",
      "duration": 5600,
      "offset": "1621600"
    },
    {
      "text": "the reward for hacking. So that's a good call. I am happy that they put this out there. All very good. But I did say one",
      "duration": 7280,
      "offset": "1627200"
    },
    {
      "text": "other proper noun there that I want to dive into a little more which was Cloudflare specifically that the",
      "duration": 6559,
      "offset": "1634480"
    },
    {
      "text": "expectation of the Cloudflare DNS fixing this didn't work. Cloud DNS did not fix",
      "duration": 5120,
      "offset": "1641039"
    },
    {
      "text": "it. Cloudflare's firewall in front of workers tried to fix this, but that had its own issues as well, which you might",
      "duration": 6161,
      "offset": "1646159"
    },
    {
      "text": "have noticed when Cloudflare went down yet again. Yes, Cloudflare has gone down again. This time it is also React's",
      "duration": 6640,
      "offset": "1652320"
    },
    {
      "text": "fault, similar to when they do DOS themselves with the use effect, but none of the React code caused it. This time it was their attempt at mitigating this",
      "duration": 7120,
      "offset": "1658960"
    },
    {
      "text": "potential exploit. They said 25 minutes of total impact. My measurement said closer to like 35 to 40. Regardless,",
      "duration": 6160,
      "offset": "1666080"
    },
    {
      "text": "Cloudflare was effectively down, including Cloudflare.com, which couldn't be loaded, which was crazy. The issue",
      "duration": 5039,
      "offset": "1672240"
    },
    {
      "text": "was not caused by a cyber attack on Cloudflare systems or malicious activity of any kind. Instead, it was triggered by changes being made to their body",
      "duration": 6000,
      "offset": "1677279"
    },
    {
      "text": "parsing logic while attempting to detect and mitigate an industry-wide vulnerability that was disclosed this week in server components. You can see",
      "duration": 6400,
      "offset": "1683279"
    },
    {
      "text": "how big the hit was to their requests. The web application firewall provides customers with protection against malicious payloads, allowing them to be",
      "duration": 6321,
      "offset": "1689679"
    },
    {
      "text": "detected and blocked. To do this, Cloudflare's proxy buffers HTTP request body content in memory for analysis.",
      "duration": 5919,
      "offset": "1696000"
    },
    {
      "text": "Before today, that buffer size was set to 128K. As part of their work to mitigate this exploit, they rolled out",
      "duration": 6240,
      "offset": "1701919"
    },
    {
      "text": "an increase to the buffer size to 1 megabyte, which is the default limit allowed by next, so that they could protect all customers because if they're",
      "duration": 6640,
      "offset": "1708159"
    },
    {
      "text": "only parsing 128k of those requests, the exploit could be deeper. They could miss it. So they increase the buffer size to",
      "duration": 5760,
      "offset": "1714799"
    },
    {
      "text": "a meg so that they could parse the whole thing and identify the bad traffic. It's being rolled out by their gradual",
      "duration": 5761,
      "offset": "1720559"
    },
    {
      "text": "deployments during rollout. We noticed our initial web application firewall testing did not support the increased buffer size as the internal test tool",
      "duration": 6479,
      "offset": "1726320"
    },
    {
      "text": "was not needed at that time and had no effect on customer traffic. We made a second change to turn it off. This one",
      "duration": 5120,
      "offset": "1732799"
    },
    {
      "text": "was implemented with their global config system. It does not perform gradual rollouts. Rather, it propagates changes within seconds to the entire fleet of",
      "duration": 6401,
      "offset": "1737919"
    },
    {
      "text": "servers in the network and is already under review due to the outage they had on the 18th of last month. It seems more",
      "duration": 6320,
      "offset": "1744320"
    },
    {
      "text": "and more like this particular system needs to be entirely rewritten if it's caused two major outages in under a",
      "duration": 6080,
      "offset": "1750640"
    },
    {
      "text": "month. In the F1 version of the proxy, under certain circumstances, the second change of turning off the web application firewall rule it for testing",
      "duration": 6720,
      "offset": "1756720"
    },
    {
      "text": "tools caused an error state that resulted in 500 HTTP error codes to be served from the network. Yeah, this Lua",
      "duration": 6400,
      "offset": "1763440"
    },
    {
      "text": "file failed to execute because it was trying to index a field that had an ill value. The cause of this outage was",
      "duration": 6640,
      "offset": "1769840"
    },
    {
      "text": "primarily their kill switch system, which is how they disable things. But they've never before applied a kill switch to a rule that had an action of",
      "duration": 6160,
      "offset": "1776480"
    },
    {
      "text": "execute. The problem was since they killed this rule, the rule result.execute doesn't exist anymore.",
      "duration": 6399,
      "offset": "1782640"
    },
    {
      "text": "But since rule resultaction was still execute, this Lua code would run. And this Lua code would set execution.",
      "duration": 7041,
      "offset": "1789039"
    },
    {
      "text": "Rule set results the number of this results index. But that means it was trying to get results index on this",
      "duration": 6800,
      "offset": "1796080"
    },
    {
      "text": "object that didn't exist because they killed it. And the result of that was that it would hard crash. Fun. More",
      "duration": 6080,
      "offset": "1802880"
    },
    {
      "text": "reasons to use type safe languages. Lua's uh Lua is a language. If you want",
      "duration": 5360,
      "offset": "1808960"
    },
    {
      "text": "to read this whole incident report, it'll be linked in the description as always. I think we covered all of the critical questions here. How does it",
      "duration": 6640,
      "offset": "1814320"
    },
    {
      "text": "work? Exploiting flight. How is it found? Somebody going deep in the internals of flight. In fact, their repo",
      "duration": 5760,
      "offset": "1820960"
    },
    {
      "text": "is hilarious. They haven't done a more traditional formal writeup yet. They were waiting for things to be patched.",
      "duration": 5520,
      "offset": "1826720"
    },
    {
      "text": "But their TLDDR is beautiful. This index gives you access to a chunk that you can then plant a custom then on the object.",
      "duration": 6319,
      "offset": "1832240"
    },
    {
      "text": "The JS runtime automatically unrivals those nested promises. Anything with a dot then. We now reenter the parser but",
      "duration": 5600,
      "offset": "1838559"
    },
    {
      "text": "with the control of a malicious fake chunk object. You plant things on the underscore response which lets you",
      "duration": 5201,
      "offset": "1844159"
    },
    {
      "text": "access a lot of gadgets when that happens. Insert several options. RCE.",
      "duration": 5039,
      "offset": "1849360"
    },
    {
      "text": "Yep. So, who's affected? Everybody using React server components or apps that could have React server components. How",
      "duration": 5681,
      "offset": "1854399"
    },
    {
      "text": "do you fix it? Update to the latest version of Nex.js or React and you're good to go. Just make sure you're up to",
      "duration": 6000,
      "offset": "1860080"
    },
    {
      "text": "date. If you are on any of these versions, fix it right now. If you have",
      "duration": 5440,
      "offset": "1866080"
    },
    {
      "text": "somebody preventing you at your job from fixing it, yell at them and do it anyways. If they keep preventing you from doing it, hit me up on Twitter and",
      "duration": 6080,
      "offset": "1871520"
    },
    {
      "text": "we'll get you a new job. This has to be fixed. Like, if you're a company using one of these React versions, just do the",
      "duration": 6240,
      "offset": "1877600"
    },
    {
      "text": "patch update. They made this as easy as possible. Go do it. And this has been a crazy experience all around. It's rare",
      "duration": 7199,
      "offset": "1883840"
    },
    {
      "text": "exploits like these are found. It doesn't say anything about the quality of the engineers building the thing. As you build complex things that solve",
      "duration": 6240,
      "offset": "1891039"
    },
    {
      "text": "complex problems, you introduce complex security issues. And everybody who's in another stack or place like all the PHP",
      "duration": 7041,
      "offset": "1897279"
    },
    {
      "text": "guys, the Rails guys, or the client side rendering people that are claiming that they are holier than thou because their",
      "duration": 7440,
      "offset": "1904320"
    },
    {
      "text": "solution doesn't have an exploit like this. Just wait. Just wait. There is",
      "duration": 5440,
      "offset": "1911760"
    },
    {
      "text": "something like this in almost every complex enough codebase. It's just a matter of who has found it. React is an",
      "duration": 6959,
      "offset": "1917200"
    },
    {
      "text": "appealing enough target to get really smart people like Lachlan trying to find these types of things. CVS happen. What",
      "duration": 6640,
      "offset": "1924159"
    },
    {
      "text": "matters isn't do they happen. What matters is how well do you handle them. This one was handled incredibly well all",
      "duration": 6321,
      "offset": "1930799"
    },
    {
      "text": "things considered. So hopefully we can as a group focus less on talking and more on making sure the web is as",
      "duration": 6399,
      "offset": "1937120"
    },
    {
      "text": "secure as possible because that's what matters here. Put your opinions aside, put your hatred of React and Verscell",
      "duration": 5601,
      "offset": "1943519"
    },
    {
      "text": "and all these other things aside and make sure we can have a responsible discussion around this type of issue so",
      "duration": 5760,
      "offset": "1949120"
    },
    {
      "text": "that we can keep the web as updated as possible. It's a great opportunity for everyone to learn to get a little more",
      "duration": 6159,
      "offset": "1954880"
    },
    {
      "text": "secure with how they implement things. And if you're interested to learn a bit more about the internals of how all this",
      "duration": 5281,
      "offset": "1961039"
    },
    {
      "text": "fancy server component stuff works in the first place, make sure you're up to date. I got nothing else to say. Until",
      "duration": 5599,
      "offset": "1966320"
    },
    {
      "text": "next time, peace nerds.",
      "duration": 3441,
      "offset": "1971919"
    }
  ],
  "transcriptText": "Sadly, this one isn't clickbait. React got hacked, and it's pretty bad. On December 3rd, a CVE regarding React went public, showcasing an exploit that was possible in versions 19, 19.1, 1911, and 19.2 of React. This is an exploit that allows for the server component flight protocol, which is how data is passed between the backend and the front end, to be hijacked to allow for remote code execution on the server. This is basically as bad as it gets. Not even basically. It got a 10 for the severity score in the official ZVE. Like it's this is as bad as it gets. It's one of the worst exploits that we've ever seen in the modern web. And the story of how it was found, how it could be exploited, the people who have already been affected, and most importantly, the entire industry working together to try and prevent this from affecting users is a really impressive story. I actually chose to delay my coverage a little bit because raising awareness of the exploit itself could cause as much damage as it resolves because people knowing how to do this exploit is scary. People like poor Eduardo have already been hacked as a result of this which is terrifying. It is worth noting that if you're on a major web provider like Cloudflare, Verscell or Netlefi that's more in the know for the React world, they have firewall mitigations that mitigate most of the risk. There is still potential they can be worked around, which is why you really, really, really should update to the latest version of React for the minor that you're on. But since Eduardo here wasn't on Verscell, he was on Hetner, he ended up getting hacked pretty bad. There is so much to dive into here from how the exploit was found to how it affects people to what we can do to prevent things like this going forward. I have no good transition for the ad spot here. Just roll it and we'll cover the rest in a sec. I have two questions for you. First, does your app have any users? If the answer is no, you can skip this ad. But if it does, question two is, are you ready to take on your first enterprise customers? If Salesforce hit you up today and said, \"Hey, we love your app. We really want to use it at the company. Can you get us set up with Octa? Just put us in touch with your IT team. Do you even have an IT team ready to go to do all of that setup?\" It's obnoxious. And that's why today's sponsor is so clutch. Work OS is the place you should start if you want to have enterprise customers. Even if not yet, if it's a plan in the future, you really should make the switch. I don't even want to think about how many potential enterprise deals we lost because we didn't have the ability to onboard those customers because we didn't have this set up right. I rolled my own offer T3 chat and I've been regretting it for a year now, which is why we just completed the move over to work OS. Yes, we actually made the move ourselves. There are so many reasons why we did this move, but honestly, the admin portal is one of the best ones. It's so easy to set up real companies on your platform. I don't know if you had to deal with this before, but the hell of trying to onboard another company onto your offplatform is miserable, especially if you don't have it set up just right. With admin portal, you literally send them a link, they click the configure single sign on button, pick whichever identity provider they're using at their company, and you're good to go. The alternative to work OS isn't rolling your own off. The alternative to work OS is hiring a whole team of people to deal with all this crap. So, it's got to be super expensive, right? Not only is it surprisingly cheap, your first million users are free. I've been super impressed since we moved over and I bet you will be too at swive.linkworks. There's a couple key questions I want to make sure we answer through this. How does it work? How is it found? What is affected? And how do I fix it? Excited to dive into all of these with you guys. But first, of course, we need to talk about how it works. GMA did a pretty good write up on this. The current code name for the exploit is React to shell because it lets you abuse the React protocol to get shell level execution, which is terrifying. This strange data structure is responsible for many sleepless nights this week across the industry. This is the now infamous react to shell payload as discovered by Lachlan Davidson now widely circulating. It's a small thing, but I do love how much they are trying to get positive like credit to the person who found this. That dev could have went and abused the hell out of this and done terrible things without disclosing it. And it would have taken forever for people to even notice. I wanted to provide my point of view on the attack, how it came about, and what we're doing, as well as the lessons learned. So, that payload that he linked is this, which doesn't look too weird if you've seen the payloads inside of like server components when things are being passed to and from the server in a modern server component react app. You might hear me saying server component in server a lot. And there's a reason for that. And no, the reason isn't because this is Nex.js specific. You'll understand the reasons very soon. But here we see the resolved model payload. It just has a then on it which is how it serializes promises. And then in here this fourth section has a console log in it which is very very specific. I think we need to do a tiny overview of React server component stuff so you can better understand how an exploit like this can happen. I just set up a really complex Nex.js app. As you can see this is so complicated. I want to just demo some of the cool things in server components that make this all matter. Let's say we have some data in here that we want to have come in later because it takes some time. I'll make a function slow component and it's going to be async because it's a slow component because to do things. So in the slow component, we'll wait that second and then render slow component. Cool. I'll make this like 3 seconds instead for a better demo. I'll put that in the page. And now when I refresh error in input stream. Interesting. What's it mad about? Oh, it just took a sec to like reblog itself. So, watch what happens. I just opened it. One, two, three, then it works. We have to wait for all of the async things to be completed before it can generate the HTML that it sends down to the user. But this is where server components have some really cool superpowers. If we put a suspense boundary around the slow component, a lot of times when I load the page now, it says loading there and then the rest comes in. And whenever I refresh, sometimes it gets a weird dev debug error because I'm in Firefox. But here it's loading. We wait and then the content comes in. It lets you have some things that get responded with immediately and other things that take time. And part of how it does this is effectively serializing the data that needs to come in later. Here it's much more focused on like the React like component protocol and the actual elements being snuck into the page. you can look at the JS and it effectively is loading another element in invisibly and then using a tiny JS payload to swap it in to the right place in the DOM which is really cool and interesting but that's not the part that this exploit touches on. Let's say we have a button component that needs some data before it can render. export function some button and this button needs a value that is a string and it will show that value when we render it. This value we'll say has to be fetched somewhere and take some time. So I'll make a fake server function that's like function async function get slow data here we'll await and then return slow data just kill this component and then use client. So the easy thing I could do here is in here await get slow data. So like con data equals await get slow data and then pass it to the button component. But then this has to be async. I can't really determine anything there. What's really cool with server components is you can pass down a promise. So if I pass this down instead of value string, it's value but it's a promise or a string instead. What I can do differently is pass that directly. I grab some button and now I'm passing this promise. But I can't do anything just with the promise. I try to render that, it's not going to work. So I can do a couple different things. I could do the fancy like use effect use state to get it. But there's also just use. Look at that. It all figured itself out. So now I have the data from using this promise. You get the idea. But since it's literally just a promise, I can go a little further like use effect and now I have this use effect that will only run when value changes which it won't cuz it's a promise. This promise gets passed down to the client component and then you can do things with it. So if we look at the terminal here, you will see after the promise loads, which takes a few seconds, you get the promise results slow data because I just passed a promise from the server to the client. You cannot convince me this isn't cool as The fact that you can take a promise or data or work being done on the server, pass it to a client component and then await it on client. What use does here is it is suspending until this promise is resolved. So if I comment this out and instead have data set datas use state and then I set the data when we get it. I could have a different case here where it's on client. If no data return loading, I can now kill the suspense boundaries here. And something broke in the DOM. There we go. I think that's cool as The fact that you can take a promise and pass it to a client component and use it how you would want to is incredible. Obviously, you shouldn't do it this way. Like, we have the primitives built in to do it better. Like, const data is use. And now we can just kill this state. So, it will always exist now, which is another one of those cool differences cuz instead of having the different states in this component, what this does is it prevents this component from rendering until the data has been resolved. It's it's so cool. These patterns are great. There's a reason that the React team has put so much time into this. But in order for all of this to work, in order to have the concept of like serializing a promise from server to client, you have to make a protocol for it. Because web standards don't have a concept of serializing a promise. If you want to do things like this, you can't just rely on JSON. It's not that simple. You need to do more. You need to make your own protocol, which is what React did with the flight protocol. It's a big part of how these things being passed from server to client and also client to server were able to work. There is one last important piece which is how the form data and actions behave. So I'll make another component in here function form example. So we have our form, we have this input and then submit. And if I type something here like something and hit submit work is happening. But if I go over here, you'll see form data. Form data has this action identifier and name colon something. Obviously this comes through with the form data because this is the form and when you submit it, it goes to the server with the contents of the form. But what the is this thing? What's this action ID empty string value? This is how React allows you to do cool things like write an action in line in this form. So the server code that gets executed when you submit this form is identified by the server by putting a hidden field in this form that is passed by the client to the server when you fire it. Because if you had three different forms and all of them are posed to the same URL, how is React and in this case Nex going to identify which is which? The actions protocol is a big part of how it does it. So if we actually look at the DOM here, you will see in this form, there's more going on than just the things we wrote. We have this hidden input type is hidden name, action ID, all of that. This is how the right function on the server is identified from what's submitted on the client. Otherwise, there'd be no way to link these things together. These are the complex layers that have enabled a CVE like this to happen. Not that like these things are inherently bad and insecure, more that new things had to be invented to allow for these patterns to exist. One more quick example of how this can get messy. If you have some value in the body of this component and you want to use that down here, how does it know what that value was? Because it's not in the form and the form is submitting. So, we want to have the right random value for when this ran. So what React will do is it will quietly embed a hashed version of this inside of the component. Let me save. And that see all of these new fields that appeared. What's happening here is it's serializing an encrypted version of the data that exists in this closure, embedding it in the form, and then that gets submitted up when you hit submit like any data in a form does where the server can decrypt it and effectively recreate the state it was in when you defined this function. It allows for the intuitive behavior to work which is I have some value here. I define an action. I call this value in this subclosure and it works. But you need to have that data there in order to recreate the state because this component run for this specific instance that you're seeing doesn't exist on the server after it sent the response. So it has to be recreated when you run your action. And this is super super cool for a bunch of reasons. One of the biggest is you don't need JavaScript on for it to work. because we're just using traditional form data and if your server turns off and back on or you're using serverless or anything like that, it just works as expected. It is incredibly impressive that this chaotic looking solution when you look at the DOM here gives such a simple and intuitive developer experience that also composes really well too. I'm very impressed with this stuff. I was skeptical at first, but there was a lot of use cases like let's say that instead of this being a form, this is a row in a table and you want to have a delete button. Instead of having to pass the ID of the deletion every single time and having to either put that in the form and it doesn't work with Noode.js or having to call a specific function with the right ID at the right time, it just exists as part of the component render and the action can just be a delete click. It makes a lot of things like that way simpler and simple makes maintaining your codebase and scaling your codebase way easier. It's a good thing. These are hard things that were invented by the React team in order to enable better developer experience. But at the core of all of this is that flight protocol which allows for things other than just form data in JSON to be sent up and down and to encode other things in those payloads. So if we go back to this payload that Garmmo had posted from Lachlan the dev who figured this all out you'll see here we have our initial payload and then we have this key one that has a value of then map then length yada yada thes are here because this is a promise being serialized over the wire which allows you to know on the client side okay there is more data coming it will be in this rough shape I can wait until that data comes here and also the same roughly on the server. So what makes this payload so special? Here is the most minimal possible working exploit to take advantage of this status resolve model reason zero. We have the response prefix of console log and then a constructor in the form data getter. So how does this work? If this body sent to any server running the vulnerable flight code like a modern next app, the console log string will be evaluated server side. That string can do virtually anything. run programs, extract secrets, make network calls. In the case of poor Eduardo here, get rude on his machine and start Bitcoin mining on it. The two key ingredients of the exploits zero and one are called chunks in flight lingo. The entry point of the exploit is, as I foreshadowed earlier, flight's key and awesome capability to stream promised data. The syntax for that is the at in the one the dollar sign at zero chunk. It's saying that zero is a promise. So, what is the resolve model thing? It's a genius piece of the exploit. While flight is intended to transport user objects, Lachlan found a way to confuse React. He's essentially expressing internal state, which is an object that's supposed to be private and contains React's internal bookkeeping. This is similar to the stuff I was showing where it's doing the form identification and passing this data in for you. It's how React keeps track of the state on client so that it could recreate it properly on server. Anytime React has to represent an in-flight object, it uses an internal data structure to keep track of the status. in resolve model means that a value is ready to be used. The key to the hack is the then piece. In JavaScript, if an object quacks like a promise, which means it has a then, then it's treated as a promise. Since we used this syntax, React will eventually await the data. To abuse this machinery, we set then the dollar one col then, which will then be called recursively. This is where flight's glaring emission happens. The colon syntax is designed to introduce references between userdefined objects, not to access the internal machinery of the JS runtime itself. A lot of exploits like this in JavaScript land are people accessing proto or the prototype objects similar ways. But if you're freely able to access those, that's a smoking gun for this type of vulnerability. The patch was to introduce a has own property call here to make sure that the value that we are decoding hasn't been modified or had these things overridden in any meaningful way. This is the primary safety emission in React and it's a fundamental one is comparable to an out-of-bounds memory access and C or use after free. Once we flow React into resolving the chunk, it's initialized with a hijacked fake underscore response. The next key the attack is to access a code evaluation mechanism. You'll notice the attack use a value that references a dollar sign B which stands for blob. Well, in this case, blob value then. Why did the attacker choose to represent a blob? In the React codebase, there's a couple lines that look like this. Where we have a blob and we take from the form data, we get on it with the blob key. Now that the attacker is controlling the form data as well as prefix, all that's left is to get the get to evaluate arbitrary code and then blob key to support it. And this is the last key to this puzzle. In JavaScript, there are two basic mechanisms to evaluate arbitrary code. Eval and new function, but neither are present here, right? Except for this mysterious get colon dollar sign 1 col then constructor piece. By accessing the then property, we're getting access to an instance of a function. And the JavaScript happily lets us access its constructor. Once again, something that could be prevented by a has own property check. Final exploit ends up semantically looking like this. Function console.log. Since they're passing this in through the prefix and the way that this is executed on the server side is prefix plus ID, adding the random content to the end of your exploit would cause the syntax to break. So they always put the comment syntax here because then when the ID gets added after it's resolved as a comment and gets ignored. One of the many clever layers here. As GMO said at the top, just position of a glaring emission of a safety check combined with a stunningly brilliant mechanism to exploit it. The solution is like a brain teaser, a riddle to test your hacking skills, or a capture the flag type of exercise. This is another instance of not trusting user input. It's so important to have every single layer you possibly can when a user is submitting data to your server and you are doing things based on it. This one was sly and subtle. It would have been very hard for anyone to see this. It's pretty impressive when you think about it how long React 19's been out for, how many people are building on it, that no one has noticed this yet. It's a very complex exploit to figure out the execution pipeline within the ReactFlight protocol deeply enough to find this one edge and sneak things through. It really is a genius exploit. So, we've now covered how does it work. We've roughly covered how was it found. Lachlan was a god digging deep in it and thankfully went through all of the correct reporting chains to get this identified and fixed. The report was privately disclosed way before the public one. The React team worked really hard to collaborate with various vendors that do a lot of hosting for modern React applications in order to get this stuff handled as much as possible on the server side. Since this problem lives so deeply in React itself, the best you can do outside of it on like the firewall level is try your best to identify payloads that match this shape and prevent them. But if another shape is discovered by someone exploiting this, the firewall checks cannot really protect you from it. So they did their best and took the existing shapes and things we know about the exploit and all of the major web providers that have Nex as a first class citizen have done their best to block this all on a firewall level. So there's a good chance you're safe even if you haven't updated. That said, make sure you're on the latest patch version like 1912 or 1921 because this has been fixed in all of the latest updates for React that were just pushed. And for the sake of poor Ricky who hasn't slept in a week, please please make sure you update. So we covered these. Now we should talk about what is affected. Obviously all of the demos I've been doing here have been next.js. That does not mean this only affects next. This exploit affects anything using React server components as recommended by meta because the exploit exists within the way that data is encoded and decoded for server components. The vulnerabilities present in 1909 1919 1911 192 for React server DOM Webpack, React server DOM parcel and React server DOM turbo pack and these are used in everything from React Router to Waku. They are not using Tanstack start because Tanstack starter components yet. But if they had introduced server components, it would likely also be affected. 1901, 1912, and 1921 have all remediated this. So if you're on any of these versions of React, you're good. And if you're on 18, you're fine. You should be able to update your app trivially if you're on any of the affected versions. You just change the latest patch and you're fine. It's very easy to mitigate if you can actually change the code that is deployed thankfully. Next, React Router, Wacu, Parcel/RSC, VJS Plugin RSC, and RWSDK are all affected. And as they say on the React blog, they've worked with a number of hosting providers to apply temporary mitigations. You should not depend on these to secure your app, and you should still update immediately. I know what your next question is going to be. I don't use server components so I am good. Right? Depends on the tools you're using and if server components are enabled at all because you can take an app that's all client components and if it has a server renderer at all running on a server that's yours or Verscell's, Cloudflares, Nellifis, whoevers, you can still hit this flight endpoint and trigger things. So, if you're not using server components, but you are using one of these late versions that includes any of the packages that were listed here, any of these that are able to do server components, you are potentially vulnerable and you really, really should update. Seriously, if you're on any of these versions or know anybody on any of these versions, be annoying until they update. This is one of the few times that you can be a righteous reply guy obnoxious If you're on one of these and have not updated, you need to now. I can't emphasize this enough. It is very very important that you update to the latest version as aggressively and soon as possible. They also posted a timeline which is really cool. Lachland originally reported this vulnerability via the metabug bounty on November 29th and by the 30th the researchers at Meta had confirmed and began working with the React team to fix. Literally 5 days later not even this went public. That is a crazy turnaround time to go from initial reporting to fixed worked with all the providers and publicly disclosed is insane. I have a lot of respect to them for going public with the disclosure as early as they did too because it's all in open- source stuff and they wanted to make sure people take the need to upgrade seriously. But it's also a tough balancing act because if you share enough detail of the exploit, you're giving misaligned people a nice edge where they can learn how to do the exploit from the resources that you provide. And if those people are faster than the people doing the patching, they're screwed. But finding the right balance of disclosing enough to make sure the severity is understood without giving usable reproductions that people can then go abuse, it's a tough balance. Even Aiden, who has been giving a lot of arguably deserved to the React Next teams historically, said that this was a world-class demo in how to handle critical vulnerabilities in large scale open source. They did really well. They did this all right. One more piece of Versel and Meta doing this responsibly. Malta, CTO of Verscell, just announced that they put out a new dedicated hacker one program for people who are finding ways to bypass the CVE protections they put on the firewall. Again, you're only safe if you update to the latest version of the package. But if you can't or haven't, the firewall is the only protection. They did their best to make it as safe as possible. But since it's a layer put around this really unsafe thing at the core, if you can find a way around it, the exploit is effectively still active. And that's why they put out this bounty. Because if you find one of those exploits, you can make 50k by telling them about it. Or you can go exploit it yourself, which was what happened to poor Eduardo here. Let's break down how he got hacked. Poor guy. I woke up to a terrifying email from Hzner. Net scan detected. My server was blocked and a botnet was using my IP to attack others. I dug into the logs and I found the anatomy of the attack. He looked at htop and saw his CPU usage was crazy. This random process running wild and connections to an IP address in the Netherlands. My server wasn't serving my app anymore. It was mining crypto for someone else. The culprit wasn't some SSH brute force. It was in his Nex.js container. The malware was sophisticated. It renamed itself to engine XS and Apache so it would look like a web server. It even had a killer script that would hunt other hacker miners and kill them so that his would get priority. The root cause is that the Nex.js CVE exploit almost certainly was what was used here. He's running on Nex 1554 behind Cloudflare DNS, but the recent fix on Cloudflare DNS didn't work. No, the Cloudflare DNS isn't going to put up a firewall in your next app on Hetner for you. No, not reasonable to expect that. Regardless, you should have updated. This is again you really need to update. The Docker container was running as root. Coolify deploys like this when using next packs and I never changed it. That is just how Nyx packs work by default from my understanding. But that is bad. His next app was deployed as root which means if you exploit the next app, you now have root. So because of the user root, the malware could install cron systemd and persistent scripts to survive reboots. So it's able to infect the whole server from a sing.js docker. The hacker installed a whole tool set in the instance. this Apache installer that's fake of course the cron route which would set up a cron to persist the exploit and the c.json JSON which was the wallet config which is where the money should be dumped when it mines fix kill the container scrub the host extract the malware for analysis real is in the docker file if you're deploying node next do not use the default route you must create a custom user and use that user instead your containers now it's important if you're running nextjs in a container in a server somewhere please go check this even if you're not on an exploitable version it's very useful to go check but the reason I was bringing this up now is how much money was made by the hacker this is somebody who chose to hack instead of disclose to be fair they are using a hack that already exists and is public. They're not sending any novel information, but they are exploiting it. And through all of their use with this, there's a wallet that the money gets dumped to. Since it's on blockchain, you can look at how much money they've made. $4.26 a day. So once again, if you do manage to find a novel exploit here, your options are maybe make $4 a day by using it and breaking the law or crazy report it to Hacker 1 to Verscell and potentially get paid $50,000. That's in my opinion a much better deal and that's why they put this up because it's important that they make the reward for reporting meaningfully better and more noble than the reward for hacking. So that's a good call. I am happy that they put this out there. All very good. But I did say one other proper noun there that I want to dive into a little more which was Cloudflare specifically that the expectation of the Cloudflare DNS fixing this didn't work. Cloud DNS did not fix it. Cloudflare's firewall in front of workers tried to fix this, but that had its own issues as well, which you might have noticed when Cloudflare went down yet again. Yes, Cloudflare has gone down again. This time it is also React's fault, similar to when they do DOS themselves with the use effect, but none of the React code caused it. This time it was their attempt at mitigating this potential exploit. They said 25 minutes of total impact. My measurement said closer to like 35 to 40. Regardless, Cloudflare was effectively down, including Cloudflare.com, which couldn't be loaded, which was crazy. The issue was not caused by a cyber attack on Cloudflare systems or malicious activity of any kind. Instead, it was triggered by changes being made to their body parsing logic while attempting to detect and mitigate an industry-wide vulnerability that was disclosed this week in server components. You can see how big the hit was to their requests. The web application firewall provides customers with protection against malicious payloads, allowing them to be detected and blocked. To do this, Cloudflare's proxy buffers HTTP request body content in memory for analysis. Before today, that buffer size was set to 128K. As part of their work to mitigate this exploit, they rolled out an increase to the buffer size to 1 megabyte, which is the default limit allowed by next, so that they could protect all customers because if they're only parsing 128k of those requests, the exploit could be deeper. They could miss it. So they increase the buffer size to a meg so that they could parse the whole thing and identify the bad traffic. It's being rolled out by their gradual deployments during rollout. We noticed our initial web application firewall testing did not support the increased buffer size as the internal test tool was not needed at that time and had no effect on customer traffic. We made a second change to turn it off. This one was implemented with their global config system. It does not perform gradual rollouts. Rather, it propagates changes within seconds to the entire fleet of servers in the network and is already under review due to the outage they had on the 18th of last month. It seems more and more like this particular system needs to be entirely rewritten if it's caused two major outages in under a month. In the F1 version of the proxy, under certain circumstances, the second change of turning off the web application firewall rule it for testing tools caused an error state that resulted in 500 HTTP error codes to be served from the network. Yeah, this Lua file failed to execute because it was trying to index a field that had an ill value. The cause of this outage was primarily their kill switch system, which is how they disable things. But they've never before applied a kill switch to a rule that had an action of execute. The problem was since they killed this rule, the rule result.execute doesn't exist anymore. But since rule resultaction was still execute, this Lua code would run. And this Lua code would set execution. Rule set results the number of this results index. But that means it was trying to get results index on this object that didn't exist because they killed it. And the result of that was that it would hard crash. Fun. More reasons to use type safe languages. Lua's uh Lua is a language. If you want to read this whole incident report, it'll be linked in the description as always. I think we covered all of the critical questions here. How does it work? Exploiting flight. How is it found? Somebody going deep in the internals of flight. In fact, their repo is hilarious. They haven't done a more traditional formal writeup yet. They were waiting for things to be patched. But their TLDDR is beautiful. This index gives you access to a chunk that you can then plant a custom then on the object. The JS runtime automatically unrivals those nested promises. Anything with a dot then. We now reenter the parser but with the control of a malicious fake chunk object. You plant things on the underscore response which lets you access a lot of gadgets when that happens. Insert several options. RCE. Yep. So, who's affected? Everybody using React server components or apps that could have React server components. How do you fix it? Update to the latest version of Nex.js or React and you're good to go. Just make sure you're up to date. If you are on any of these versions, fix it right now. If you have somebody preventing you at your job from fixing it, yell at them and do it anyways. If they keep preventing you from doing it, hit me up on Twitter and we'll get you a new job. This has to be fixed. Like, if you're a company using one of these React versions, just do the patch update. They made this as easy as possible. Go do it. And this has been a crazy experience all around. It's rare exploits like these are found. It doesn't say anything about the quality of the engineers building the thing. As you build complex things that solve complex problems, you introduce complex security issues. And everybody who's in another stack or place like all the PHP guys, the Rails guys, or the client side rendering people that are claiming that they are holier than thou because their solution doesn't have an exploit like this. Just wait. Just wait. There is something like this in almost every complex enough codebase. It's just a matter of who has found it. React is an appealing enough target to get really smart people like Lachlan trying to find these types of things. CVS happen. What matters isn't do they happen. What matters is how well do you handle them. This one was handled incredibly well all things considered. So hopefully we can as a group focus less on talking and more on making sure the web is as secure as possible because that's what matters here. Put your opinions aside, put your hatred of React and Verscell and all these other things aside and make sure we can have a responsible discussion around this type of issue so that we can keep the web as updated as possible. It's a great opportunity for everyone to learn to get a little more secure with how they implement things. And if you're interested to learn a bit more about the internals of how all this fancy server component stuff works in the first place, make sure you're up to date. I got nothing else to say. Until next time, peace nerds."
}